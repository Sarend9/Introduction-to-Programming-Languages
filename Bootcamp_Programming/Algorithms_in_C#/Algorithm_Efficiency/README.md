# Демонстрация алгоритмов

В этом репозитории представлены примеры различных видов алгоритмов и их сложность. Ниже приведены описания каждого алгоритма и примеры их использования.

## Виды алгоритмов

1. **Константные алгоритмы (O(1))**
   
   Пример алгоритма, который выполняет фиксированное количество операций независимо от входных данных.

2. **Логарифмические алгоритмы (O(log2(n))**
   
   Пример алгоритма: бинарный поиск. Эти алгоритмы имеют сложность, которая логарифмически зависит от размера входных данных.

3. **Линейные алгоритмы (O(n))**
   
   Пример алгоритма: простой поиск. Эти алгоритмы имеют линейную зависимость от размера входных данных.

4. **Линейно-логарифмические алгоритмы**
   
   Пример алгоритма: быстрая сортировка. Эти алгоритмы сочетают в себе линейную и логарифмическую сложность.

5. **Квадратные алгоритмы (O(n^2))**
   
   Примеры алгоритмов: пузырьковая сортировка, сортировка выбором, сортировка вставками. Эти алгоритмы имеют квадратичную сложность.

6. **Кубические алгоритмы**
   
   Пример алгоритма: работа с трехмерными массивами. Эти алгоритмы имеют кубическую сложность.

## Задача 1: Сумма чисел от 1 до n

В этой задаче мы рассмотрим два типа алгоритмов для вычисления суммы чисел от 1 до n.

### Линейный алгоритм (O(n))

```csharp
int result1 = 0;
for (int i = 1; i <= n1; i++) // O(n)
{
    result1 += i;
}
```

Этот алгоритм вычисляет сумму чисел от 1 до n. Его сложность O(n), так как количество действий зависит от значения n.

### Константный алгоритм (O(1))

```csharp
Console.WriteLine($"* Сумма чисел от 1 до {n2} равна {(1 + n2) / 2.0 * n2}");
```

Этот алгоритм также вычисляет сумму чисел от 1 до n, но его сложность O(1), так как он выполняет фиксированное количество действий, не зависящих от значения n.

## Бинарный поиск (O(log₂n))

Бинарный поиск - это алгоритм для поиска элемента в отсортированном массиве. Он имеет логарифмическую сложность, что означает, что количество действий растет логарифмически с увеличением размера массива.

Представим, что нам нужно найти число 67 в диапазоне от 1 до 100. Мы можем использовать бинарный поиск для этой задачи. Процесс поиска может быть описан следующим образом:

1. Исходно заданный диапазон: [1, 100]
2. Проверяем, больше ли 67, чем средний элемент диапазона, который равен (1 + 100) / 2 = 50.5. Ответ - да, 67 больше.
3. Теперь наш новый диапазон становится [51, 100].
4. Снова проверяем средний элемент: (51 + 100) / 2 = 75.5. Ответ - нет, 67 меньше.
5. Новый диапазон: [51, 75].
6. Снова проверяем средний элемент: (51 + 75) / 2 = 63. Ответ - да, 67 больше.
7. Новый диапазон: [64, 75].
8. Проверяем средний элемент: (64 + 75) / 2 = 69.5. Ответ - да, 67 меньше.
9. Новый диапазон: [64, 68].
10. Проверяем средний элемент: (64 + 68) / 2 = 66. Ответ - нет, 67 больше.
11. Новый диапазон: [67, 68].
12. Проверяем средний элемент: (67 + 68) / 2 = 67.5. Ответ - нет, 67 больше.
13. Новый диапазон: [67, 67].
14. Теперь наш диапазон состоит только из числа 67, и мы нашли искомый элемент.

В результате бинарного поиска нам потребовалось всего 7 попыток, чтобы найти число 67 в отсортированном диапазоне от 1 до 100. Сложность алгоритма бинарного поиска составляет O(log₂(n)), что означает, что он имеет логарифмическую сложность по времени и эффективен для больших наборов данных.



Пример бинарного поиска:

```csharp
// Ваш код для бинарного поиска здесь
```

## Быстрая сортировка (O(n * log₂n))

Быстрая сортировка (Quick Sort) - это алгоритм сортировки, который имеет сложность O(n * log₂n), где n - количество элементов в массиве.

Его суть заключается в разделении массива на две части: одна часть содержит элементы, которые меньше опорного элемента, а другая часть содержит элементы, которые больше или равны опорному элементу. Этот процесс выполняется рекурсивно до тех пор, пока массив не будет полностью отсортирован.

Процесс быстрой сортировки можно описать следующим образом:

1. Выбирается опорный элемент из массива. Обычно в качестве опорного элемента выбирается первый элемент массива.

2. Создаются два подмассива: один для элементов меньше опорного, и второй - для элементов больше или равных опорному.

3. Рекурсивно применяется быстрая сортировка к обоим подмассивам.

4. В конечном итоге, элементы меньше опорного будут находиться слева от опорного элемента, а элементы больше или равные опорному - справа.

Пример:

Допустим, у нас есть массив: [34, -10, 23, 5, 2, 1].

1. Выбираем опорный элемент, например, 34.

2. Создаем два подмассива:
   - Подмассив элементов меньше 34: [-10, 23, 5, 2, 1]
   - Подмассив элементов больше или равных 34: []

3. Применяем быструю сортировку к обоим подмассивам:
   - Для подмассива с элементами меньше 34: [-10, 23, 5, 2, 1]
     - Опорный элемент: -10.
     - Подмассив элементов меньше -10: []
     - Подмассив элементов больше или равных -10: [23, 5, 2, 1]
   - Для подмассива с элементами больше или равными 34: []

4. По завершении рекурсивных вызовов, объединяем отсортированные подмассивы:
   - [-10] + [23, 5, 2, 1] + [34] + []

Теперь весь массив отсортирован: [-10, 1, 2, 5, 23, 34].

Быстрая сортировка является одним из наиболее эффективных алгоритмов сортировки и широко используется в реальных приложениях.

Пример быстрой сортировки:

```csharp
// Ваш код для быстрой сортировки здесь
```